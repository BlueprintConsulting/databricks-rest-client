/*
 * Jobs API 2.1
 * The Jobs API allows you to create, edit, and delete jobs.
 *
 * The version of the OpenAPI document: 2.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.edmunds.rest.databricks.DTO.jobs;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonValue;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * JobSettingsDTO
 */
@JsonPropertyOrder({
        JobSettingsDTO.JSON_PROPERTY_NAME,
        JobSettingsDTO.JSON_PROPERTY_TASKS,
        JobSettingsDTO.JSON_PROPERTY_JOB_CLUSTERS,
        JobSettingsDTO.JSON_PROPERTY_EMAIL_NOTIFICATIONS,
        JobSettingsDTO.JSON_PROPERTY_TIMEOUT_SECONDS,
        JobSettingsDTO.JSON_PROPERTY_SCHEDULE,
        JobSettingsDTO.JSON_PROPERTY_MAX_CONCURRENT_RUNS,
        JobSettingsDTO.JSON_PROPERTY_FORMAT
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaJerseyServerCodegen", date = "2022-03-09T23:53:34.566-08:00[America/Los_Angeles]")
public class JobSettingsDTO {
    public static final String JSON_PROPERTY_NAME = "name";
    public static final String JSON_PROPERTY_TASKS = "tasks";
    public static final String JSON_PROPERTY_JOB_CLUSTERS = "job_clusters";
    public static final String JSON_PROPERTY_EMAIL_NOTIFICATIONS = "email_notifications";
    public static final String JSON_PROPERTY_TIMEOUT_SECONDS = "timeout_seconds";
    public static final String JSON_PROPERTY_SCHEDULE = "schedule";
    public static final String JSON_PROPERTY_MAX_CONCURRENT_RUNS = "max_concurrent_runs";
    public static final String JSON_PROPERTY_FORMAT = "format";
    @JsonProperty(JSON_PROPERTY_NAME)
    private String name = "Untitled";
    @JsonProperty(JSON_PROPERTY_TASKS)
    private List<JobTaskSettings> tasks = null;
    @JsonProperty(JSON_PROPERTY_JOB_CLUSTERS)
    private List<JobCluster> jobClusters = null;
    @JsonProperty(JSON_PROPERTY_EMAIL_NOTIFICATIONS)
    private JobEmailNotificationsDTO emailNotifications;
    @JsonProperty(JSON_PROPERTY_TIMEOUT_SECONDS)
    private Integer timeoutSeconds;
    @JsonProperty(JSON_PROPERTY_SCHEDULE)
    private CronScheduleDTO schedule;
    @JsonProperty(JSON_PROPERTY_MAX_CONCURRENT_RUNS)
    private Integer maxConcurrentRuns;
    @JsonProperty(JSON_PROPERTY_FORMAT)
    private FormatEnum format;

    public JobSettingsDTO name(String name) {
        this.name = name;
        return this;
    }

    /**
     * An optional name for the job.
     *
     * @return name
     **/
    @JsonProperty(value = "name")
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public JobSettingsDTO tasks(List<JobTaskSettings> tasks) {
        this.tasks = tasks;
        return this;
    }

    public JobSettingsDTO addTasksItem(JobTaskSettings tasksItem) {
        if (this.tasks == null) {
            this.tasks = new ArrayList<JobTaskSettings>();
        }
        this.tasks.add(tasksItem);
        return this;
    }

    /**
     * A list of task specifications to be executed by this job.
     *
     * @return tasks
     **/
    @JsonProperty(value = "tasks")
    public List<JobTaskSettings> getTasks() {
        return tasks;
    }

    public void setTasks(List<JobTaskSettings> tasks) {
        this.tasks = tasks;
    }

    public JobSettingsDTO jobClusters(List<JobCluster> jobClusters) {
        this.jobClusters = jobClusters;
        return this;
    }

    public JobSettingsDTO addJobClustersItem(JobCluster jobClustersItem) {
        if (this.jobClusters == null) {
            this.jobClusters = new ArrayList<JobCluster>();
        }
        this.jobClusters.add(jobClustersItem);
        return this;
    }

    /**
     * A list of job cluster specifications that can be shared and reused by tasks of this job. Libraries cannot be declared in a shared job cluster. You must declare dependent libraries in task settings.
     *
     * @return jobClusters
     **/
    @JsonProperty(value = "job_clusters")
    public List<JobCluster> getJobClusters() {
        return jobClusters;
    }

    public void setJobClusters(List<JobCluster> jobClusters) {
        this.jobClusters = jobClusters;
    }

    public JobSettingsDTO emailNotifications(JobEmailNotificationsDTO emailNotifications) {
        this.emailNotifications = emailNotifications;
        return this;
    }

    /**
     * Get emailNotifications
     *
     * @return emailNotifications
     **/
    @JsonProperty(value = "email_notifications")
    public JobEmailNotificationsDTO getEmailNotifications() {
        return emailNotifications;
    }

    public void setEmailNotifications(JobEmailNotificationsDTO emailNotifications) {
        this.emailNotifications = emailNotifications;
    }

    public JobSettingsDTO timeoutSeconds(Integer timeoutSeconds) {
        this.timeoutSeconds = timeoutSeconds;
        return this;
    }

    /**
     * An optional timeout applied to each run of this job. The default behavior is to have no timeout.
     *
     * @return timeoutSeconds
     **/
    @JsonProperty(value = "timeout_seconds")
    public Integer getTimeoutSeconds() {
        return timeoutSeconds;
    }

    public void setTimeoutSeconds(Integer timeoutSeconds) {
        this.timeoutSeconds = timeoutSeconds;
    }

    public JobSettingsDTO schedule(CronScheduleDTO schedule) {
        this.schedule = schedule;
        return this;
    }

    /**
     * Get schedule
     *
     * @return schedule
     **/
    @JsonProperty(value = "schedule")
    public CronScheduleDTO getSchedule() {
        return schedule;
    }

    public void setSchedule(CronScheduleDTO schedule) {
        this.schedule = schedule;
    }

    public JobSettingsDTO maxConcurrentRuns(Integer maxConcurrentRuns) {
        this.maxConcurrentRuns = maxConcurrentRuns;
        return this;
    }

    /**
     * An optional maximum allowed number of concurrent runs of the job.  Set this value if you want to be able to execute multiple runs of the same job concurrently. This is useful for example if you trigger your job on a frequent schedule and want to allow consecutive runs to overlap with each other, or if you want to trigger multiple runs which differ by their input parameters.  This setting affects only new runs. For example, suppose the job’s concurrency is 4 and there are 4 concurrent active runs. Then setting the concurrency to 3 won’t kill any of the active runs. However, from then on, new runs are skipped unless there are fewer than 3 active runs.  This value cannot exceed 1000\\. Setting this value to 0 causes all new runs to be skipped. The default behavior is to allow only 1 concurrent run.
     *
     * @return maxConcurrentRuns
     **/
    @JsonProperty(value = "max_concurrent_runs")
    public Integer getMaxConcurrentRuns() {
        return maxConcurrentRuns;
    }

    public void setMaxConcurrentRuns(Integer maxConcurrentRuns) {
        this.maxConcurrentRuns = maxConcurrentRuns;
    }

    public JobSettingsDTO format(FormatEnum format) {
        this.format = format;
        return this;
    }

    /**
     * Used to tell what is the format of the job. This field is ignored in Create/Update/Reset calls. When using the Jobs API 2.1 this value is always set to &#x60;\&quot;MULTI_TASK\&quot;&#x60;.
     *
     * @return format
     **/
    @JsonProperty(value = "format")
    public FormatEnum getFormat() {
        return format;
    }

    public void setFormat(FormatEnum format) {
        this.format = format;
    }

//    @JsonIgnore
//    @Deprecated
//    public String getExistingClusterId() {
//        if (tasks != null && !tasks.isEmpty()) {
//            return tasks.get(0).getExistingClusterId();
//        }
//        return null;
//    }
//
//    @JsonIgnore
//    @Deprecated
//    public NewClusterDTO getNewCluster(){
//        if (tasks != null && !tasks.isEmpty()) {
//            return tasks.get(0).getNewCluster();
//        }
//        return null;
//    }
//
//    @JsonIgnore
//    @Deprecated
//    public void setNewCluster(NewClusterDTO newClusterDTO){
//        if (tasks == null || tasks.isEmpty() ) {
//            throw new IllegalArgumentException("can't udpate cluster setting , no tasks defined");
//        }
//        if (tasks == null || tasks.isEmpty() ) {
//            throw new IllegalArgumentException("can't udpate cluster setting , more then 1 tasks defined");
//        }
//        JobTaskSettings jobTaskSettings = tasks.get(0);
//        jobTaskSettings.setNewCluster(newClusterDTO);
//    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        JobSettingsDTO jobSettings = (JobSettingsDTO) o;
        return Objects.equals(this.name, jobSettings.name) &&
                Objects.equals(this.tasks, jobSettings.tasks) &&
                Objects.equals(this.jobClusters, jobSettings.jobClusters) &&
                Objects.equals(this.emailNotifications, jobSettings.emailNotifications) &&
                Objects.equals(this.timeoutSeconds, jobSettings.timeoutSeconds) &&
                Objects.equals(this.schedule, jobSettings.schedule) &&
                Objects.equals(this.maxConcurrentRuns, jobSettings.maxConcurrentRuns) &&
                Objects.equals(this.format, jobSettings.format);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, tasks, jobClusters, emailNotifications, timeoutSeconds, schedule, maxConcurrentRuns, format);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class JobSettingsDTO {\n");

        sb.append("    name: ").append(toIndentedString(name)).append("\n");
        sb.append("    tasks: ").append(toIndentedString(tasks)).append("\n");
        sb.append("    jobClusters: ").append(toIndentedString(jobClusters)).append("\n");
        sb.append("    emailNotifications: ").append(toIndentedString(emailNotifications)).append("\n");
        sb.append("    timeoutSeconds: ").append(toIndentedString(timeoutSeconds)).append("\n");
        sb.append("    schedule: ").append(toIndentedString(schedule)).append("\n");
        sb.append("    maxConcurrentRuns: ").append(toIndentedString(maxConcurrentRuns)).append("\n");
        sb.append("    format: ").append(toIndentedString(format)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }

    /**
     * Used to tell what is the format of the job. This field is ignored in Create/Update/Reset calls. When using the Jobs API 2.1 this value is always set to &#x60;\&quot;MULTI_TASK\&quot;&#x60;.
     */
    public enum FormatEnum {
        SINGLE_TASK("SINGLE_TASK"),

        MULTI_TASK("MULTI_TASK");

        private String value;

        FormatEnum(String value) {
            this.value = value;
        }

        @JsonCreator
        public static FormatEnum fromValue(String value) {
            for (FormatEnum b : FormatEnum.values()) {
                if (b.value.equals(value)) {
                    return b;
                }
            }
            throw new IllegalArgumentException("Unexpected value '" + value + "'");
        }

        @Override
        @JsonValue
        public String toString() {
            return String.valueOf(value);
        }
    }
}

