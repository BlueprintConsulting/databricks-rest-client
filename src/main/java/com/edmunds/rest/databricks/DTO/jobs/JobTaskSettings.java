/*
 * Jobs API 2.1
 * The Jobs API allows you to create, edit, and delete jobs.
 *
 * The version of the OpenAPI document: 2.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.edmunds.rest.databricks.DTO.jobs;

import com.edmunds.rest.databricks.DTO.libraries.LibraryDTO;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * JobTaskSettings
 */
@JsonPropertyOrder({
        JobTaskSettings.JSON_PROPERTY_TASK_KEY,
        JobTaskSettings.JSON_PROPERTY_DESCRIPTION,
        JobTaskSettings.JSON_PROPERTY_DEPENDS_ON,
        JobTaskSettings.JSON_PROPERTY_EXISTING_CLUSTER_ID,
        JobTaskSettings.JSON_PROPERTY_NEW_CLUSTER,
        JobTaskSettings.JSON_PROPERTY_JOB_CLUSTER_KEY,
        JobTaskSettings.JSON_PROPERTY_NOTEBOOK_TASK,
        JobTaskSettings.JSON_PROPERTY_SPARK_JAR_TASK,
        JobTaskSettings.JSON_PROPERTY_SPARK_PYTHON_TASK,
        JobTaskSettings.JSON_PROPERTY_SPARK_SUBMIT_TASK,
        JobTaskSettings.JSON_PROPERTY_PIPELINE_TASK,
        JobTaskSettings.JSON_PROPERTY_SQL_TASK,
        JobTaskSettings.JSON_PROPERTY_RUN_JOB_TASK,
        JobTaskSettings.JSON_PROPERTY_PYTHON_WHEEL_TASK,
        JobTaskSettings.JSON_PROPERTY_LIBRARIES,
        JobTaskSettings.JSON_PROPERTY_EMAIL_NOTIFICATIONS,
        JobTaskSettings.JSON_PROPERTY_TIMEOUT_SECONDS,
        JobTaskSettings.JSON_PROPERTY_MAX_RETRIES,
        JobTaskSettings.JSON_PROPERTY_MIN_RETRY_INTERVAL_MILLIS,
        JobTaskSettings.JSON_PROPERTY_RETRY_ON_TIMEOUT
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaJerseyServerCodegen", date = "2022-03-09T23:53:34.566-08:00[America/Los_Angeles]")
public class JobTaskSettings {
    public static final String JSON_PROPERTY_TASK_KEY = "task_key";
    public static final String JSON_PROPERTY_DESCRIPTION = "description";
    public static final String JSON_PROPERTY_DEPENDS_ON = "depends_on";
    public static final String JSON_PROPERTY_EXISTING_CLUSTER_ID = "existing_cluster_id";
    public static final String JSON_PROPERTY_NEW_CLUSTER = "new_cluster";
    public static final String JSON_PROPERTY_JOB_CLUSTER_KEY = "job_cluster_key";
    public static final String JSON_PROPERTY_NOTEBOOK_TASK = "notebook_task";
    public static final String JSON_PROPERTY_SPARK_JAR_TASK = "spark_jar_task";
    public static final String JSON_PROPERTY_SPARK_PYTHON_TASK = "spark_python_task";
    public static final String JSON_PROPERTY_SPARK_SUBMIT_TASK = "spark_submit_task";
    public static final String JSON_PROPERTY_PIPELINE_TASK = "pipeline_task";
    public static final String JSON_PROPERTY_SQL_TASK = "sql_task";
    public static final String JSON_PROPERTY_RUN_JOB_TASK = "run_job_task";
    public static final String JSON_PROPERTY_PYTHON_WHEEL_TASK = "python_wheel_task";
    public static final String JSON_PROPERTY_LIBRARIES = "libraries";
    public static final String JSON_PROPERTY_EMAIL_NOTIFICATIONS = "email_notifications";
    public static final String JSON_PROPERTY_TIMEOUT_SECONDS = "timeout_seconds";
    public static final String JSON_PROPERTY_MAX_RETRIES = "max_retries";
    public static final String JSON_PROPERTY_MIN_RETRY_INTERVAL_MILLIS = "min_retry_interval_millis";
    public static final String JSON_PROPERTY_RETRY_ON_TIMEOUT = "retry_on_timeout";
    @JsonProperty(JSON_PROPERTY_TASK_KEY)
    private String taskKey;
    @JsonProperty(JSON_PROPERTY_DESCRIPTION)
    private String description;
    @JsonProperty(JSON_PROPERTY_DEPENDS_ON)
    private List<Object> dependsOn = null;
    @JsonProperty(JSON_PROPERTY_EXISTING_CLUSTER_ID)
    private String existingClusterId;
    @JsonProperty(JSON_PROPERTY_NEW_CLUSTER)
    private NewClusterDTO newCluster;
    @JsonProperty(JSON_PROPERTY_JOB_CLUSTER_KEY)
    private String jobClusterKey;
    @JsonProperty(JSON_PROPERTY_NOTEBOOK_TASK)
    private NotebookTaskDTO notebookTask;
    @JsonProperty(JSON_PROPERTY_SPARK_JAR_TASK)
    private SparkJarTaskDTO sparkJarTask;
    @JsonProperty(JSON_PROPERTY_SPARK_PYTHON_TASK)
    private SparkPythonTaskDTO sparkPythonTask;
    @JsonProperty(JSON_PROPERTY_SPARK_SUBMIT_TASK)
    private SparkSubmitTaskDTO sparkSubmitTask;
    @JsonProperty(JSON_PROPERTY_PIPELINE_TASK)
    private PipelineTask pipelineTask;
    @JsonProperty(JSON_PROPERTY_SQL_TASK)
    private SqlTask sqlTask;

    @JsonProperty(JSON_PROPERTY_RUN_JOB_TASK)
    private RunJobTask runJobTask;

    @JsonProperty(JSON_PROPERTY_PYTHON_WHEEL_TASK)
    private PythonWheelTask pythonWheelTask;
    @JsonProperty(JSON_PROPERTY_LIBRARIES)
    private List<LibraryDTO> libraries = null;
    @JsonProperty(JSON_PROPERTY_EMAIL_NOTIFICATIONS)
    private JobEmailNotificationsDTO emailNotifications;
    @JsonProperty(JSON_PROPERTY_TIMEOUT_SECONDS)
    private Integer timeoutSeconds;
    @JsonProperty(JSON_PROPERTY_MAX_RETRIES)
    private Integer maxRetries;
    @JsonProperty(JSON_PROPERTY_MIN_RETRY_INTERVAL_MILLIS)
    private Integer minRetryIntervalMillis;
    @JsonProperty(JSON_PROPERTY_RETRY_ON_TIMEOUT)
    private Boolean retryOnTimeout;

    public JobTaskSettings taskKey(String taskKey) {
        this.taskKey = taskKey;
        return this;
    }

    /**
     * A unique name for the task. This field is used to refer to this task from other tasks. This field is required and must be unique within its parent job. On Update or Reset, this field is used to reference the tasks to be updated or reset. The maximum length is 100 characters.
     *
     * @return taskKey
     **/
    @JsonProperty(value = "task_key")
    public String getTaskKey() {
        return taskKey;
    }

    public void setTaskKey(String taskKey) {
        this.taskKey = taskKey;
    }

    public JobTaskSettings description(String description) {
        this.description = description;
        return this;
    }

    /**
     * An optional description for this task. The maximum length is 4096 bytes.
     *
     * @return description
     **/
    @JsonProperty(value = "description")
    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public JobTaskSettings dependsOn(List<Object> dependsOn) {
        this.dependsOn = dependsOn;
        return this;
    }

    public JobTaskSettings addDependsOnItem(Object dependsOnItem) {
        if (this.dependsOn == null) {
            this.dependsOn = new ArrayList<Object>();
        }
        this.dependsOn.add(dependsOnItem);
        return this;
    }

    /**
     * An optional array of objects specifying the dependency graph of the task. All tasks specified in this field must complete successfully before executing this task. The key is &#x60;task_key&#x60;, and the value is the name assigned to the dependent task. This field is required when a job consists of more than one task.
     *
     * @return dependsOn
     **/
    @JsonProperty(value = "depends_on")
    public List<Object> getDependsOn() {
        return dependsOn;
    }

    public void setDependsOn(List<Object> dependsOn) {
        this.dependsOn = dependsOn;
    }

    public JobTaskSettings existingClusterId(String existingClusterId) {
        this.existingClusterId = existingClusterId;
        return this;
    }

    /**
     * If existing_cluster_id, the ID of an existing cluster that is used for all runs of this task. When running tasks on an existing cluster, you may need to manually restart the cluster if it stops responding. We suggest running jobs on new clusters for greater reliability.
     *
     * @return existingClusterId
     **/
    @JsonProperty(value = "existing_cluster_id")

    public String getExistingClusterId() {
        return existingClusterId;
    }

    public void setExistingClusterId(String existingClusterId) {
        this.existingClusterId = existingClusterId;
    }

    public JobTaskSettings newCluster(NewClusterDTO newCluster) {
        this.newCluster = newCluster;
        return this;
    }

    /**
     * Get newCluster
     *
     * @return newCluster
     **/
    @JsonProperty(value = "new_cluster")
    public NewClusterDTO getNewCluster() {
        return newCluster;
    }

    public void setNewCluster(NewClusterDTO newCluster) {
        this.newCluster = newCluster;
    }

    public JobTaskSettings jobClusterKey(String jobClusterKey) {
        this.jobClusterKey = jobClusterKey;
        return this;
    }

    /**
     * If job_cluster_key, this task is executed reusing the cluster specified in &#x60;job.settings.job_clusters&#x60;.
     *
     * @return jobClusterKey
     **/
    @JsonProperty(value = "job_cluster_key")
    public String getJobClusterKey() {
        return jobClusterKey;
    }

    public void setJobClusterKey(String jobClusterKey) {
        this.jobClusterKey = jobClusterKey;
    }

    public JobTaskSettings notebookTask(NotebookTaskDTO notebookTask) {
        this.notebookTask = notebookTask;
        return this;
    }

    /**
     * Get notebookTask
     *
     * @return notebookTask
     **/
    @JsonProperty(value = "notebook_task")
    public NotebookTaskDTO getNotebookTask() {
        return notebookTask;
    }

    public void setNotebookTask(NotebookTaskDTO notebookTask) {
        this.notebookTask = notebookTask;
    }

    public JobTaskSettings sparkJarTask(SparkJarTaskDTO sparkJarTask) {
        this.sparkJarTask = sparkJarTask;
        return this;
    }

    /**
     * Get sparkJarTask
     *
     * @return sparkJarTask
     **/
    @JsonProperty(value = "spark_jar_task")
    public SparkJarTaskDTO getSparkJarTask() {
        return sparkJarTask;
    }

    public void setSparkJarTask(SparkJarTaskDTO sparkJarTask) {
        this.sparkJarTask = sparkJarTask;
    }

    public JobTaskSettings sparkPythonTask(SparkPythonTaskDTO sparkPythonTask) {
        this.sparkPythonTask = sparkPythonTask;
        return this;
    }

    /**
     * Get sparkPythonTask
     *
     * @return sparkPythonTask
     **/
    @JsonProperty(value = "spark_python_task")
    public SparkPythonTaskDTO getSparkPythonTask() {
        return sparkPythonTask;
    }

    public void setSparkPythonTask(SparkPythonTaskDTO sparkPythonTask) {
        this.sparkPythonTask = sparkPythonTask;
    }

    public JobTaskSettings sparkSubmitTask(SparkSubmitTaskDTO sparkSubmitTask) {
        this.sparkSubmitTask = sparkSubmitTask;
        return this;
    }

    /**
     * Get sparkSubmitTask
     *
     * @return sparkSubmitTask
     **/
    @JsonProperty(value = "spark_submit_task")
    public SparkSubmitTaskDTO getSparkSubmitTask() {
        return sparkSubmitTask;
    }

    public void setSparkSubmitTask(SparkSubmitTaskDTO sparkSubmitTask) {
        this.sparkSubmitTask = sparkSubmitTask;
    }

    public JobTaskSettings pipelineTask(PipelineTask pipelineTask) {
        this.pipelineTask = pipelineTask;
        return this;
    }

    /**
     * Get pipelineTask
     *
     * @return pipelineTask
     **/
    @JsonProperty(value = "pipeline_task")
    public PipelineTask getPipelineTask() {
        return pipelineTask;
    }

    public void setPipelineTask(PipelineTask pipelineTask) {
        this.pipelineTask = pipelineTask;
    }

    @JsonProperty(value = "sql_task")
    public SqlTask getSqlTask() {
        return sqlTask;
    }

    public void setSqlTask(SqlTask sqlTask) {
        this.sqlTask = sqlTask;
    }

    @JsonProperty(value = "run_job_task")
    public RunJobTask getRunJobTask() {
        return runJobTask;
    }

    public void setRunJobTask(RunJobTask runJobTak) {
        this.runJobTask = runJobTak;
    }

    public JobTaskSettings pythonWheelTask(PythonWheelTask pythonWheelTask) {
        this.pythonWheelTask = pythonWheelTask;
        return this;
    }

    /**
     * Get pythonWheelTask
     *
     * @return pythonWheelTask
     **/
    @JsonProperty(value = "python_wheel_task")
    public PythonWheelTask getPythonWheelTask() {
        return pythonWheelTask;
    }

    public void setPythonWheelTask(PythonWheelTask pythonWheelTask) {
        this.pythonWheelTask = pythonWheelTask;
    }

    public JobTaskSettings libraries(List<LibraryDTO> libraries) {
        this.libraries = libraries;
        return this;
    }

    public JobTaskSettings addLibrariesItem(LibraryDTO librariesItem) {
        if (this.libraries == null) {
            this.libraries = new ArrayList<LibraryDTO>();
        }
        this.libraries.add(librariesItem);
        return this;
    }

    /**
     * An optional list of libraries to be installed on the cluster that executes the task. The default value is an empty list.
     *
     * @return libraries
     **/
    @JsonProperty(value = "libraries")
    public List<LibraryDTO> getLibraries() {
        return libraries;
    }

    public void setLibraries(List<LibraryDTO> libraries) {
        this.libraries = libraries;
    }

    public JobTaskSettings emailNotifications(JobEmailNotificationsDTO emailNotifications) {
        this.emailNotifications = emailNotifications;
        return this;
    }

    /**
     * Get emailNotifications
     *
     * @return emailNotifications
     **/
    @JsonProperty(value = "email_notifications")
    public JobEmailNotificationsDTO getEmailNotifications() {
        return emailNotifications;
    }

    public void setEmailNotifications(JobEmailNotificationsDTO emailNotifications) {
        this.emailNotifications = emailNotifications;
    }

    public JobTaskSettings timeoutSeconds(Integer timeoutSeconds) {
        this.timeoutSeconds = timeoutSeconds;
        return this;
    }

    /**
     * An optional timeout applied to each run of this job task. The default behavior is to have no timeout.
     *
     * @return timeoutSeconds
     **/
    @JsonProperty(value = "timeout_seconds")
    public Integer getTimeoutSeconds() {
        return timeoutSeconds;
    }

    public void setTimeoutSeconds(Integer timeoutSeconds) {
        this.timeoutSeconds = timeoutSeconds;
    }

    public JobTaskSettings maxRetries(Integer maxRetries) {
        this.maxRetries = maxRetries;
        return this;
    }

    /**
     * An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with the &#x60;FAILED&#x60; result_state or &#x60;INTERNAL_ERROR&#x60; &#x60;life_cycle_state&#x60;. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry.
     *
     * @return maxRetries
     **/
    @JsonProperty(value = "max_retries")
    public Integer getMaxRetries() {
        return maxRetries;
    }

    public void setMaxRetries(Integer maxRetries) {
        this.maxRetries = maxRetries;
    }

    public JobTaskSettings minRetryIntervalMillis(Integer minRetryIntervalMillis) {
        this.minRetryIntervalMillis = minRetryIntervalMillis;
        return this;
    }

    /**
     * An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
     *
     * @return minRetryIntervalMillis
     **/
    @JsonProperty(value = "min_retry_interval_millis")
    public Integer getMinRetryIntervalMillis() {
        return minRetryIntervalMillis;
    }

    public void setMinRetryIntervalMillis(Integer minRetryIntervalMillis) {
        this.minRetryIntervalMillis = minRetryIntervalMillis;
    }

    public JobTaskSettings retryOnTimeout(Boolean retryOnTimeout) {
        this.retryOnTimeout = retryOnTimeout;
        return this;
    }

    /**
     * An optional policy to specify whether to retry a task when it times out. The default behavior is to not retry on timeout.
     *
     * @return retryOnTimeout
     **/
    @JsonProperty(value = "retry_on_timeout")
    public Boolean getRetryOnTimeout() {
        return retryOnTimeout;
    }

    public void setRetryOnTimeout(Boolean retryOnTimeout) {
        this.retryOnTimeout = retryOnTimeout;
    }


    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        JobTaskSettings jobTaskSettings = (JobTaskSettings) o;
        return Objects.equals(this.taskKey, jobTaskSettings.taskKey) &&
                Objects.equals(this.description, jobTaskSettings.description) &&
                Objects.equals(this.dependsOn, jobTaskSettings.dependsOn) &&
                Objects.equals(this.existingClusterId, jobTaskSettings.existingClusterId) &&
                Objects.equals(this.newCluster, jobTaskSettings.newCluster) &&
                Objects.equals(this.jobClusterKey, jobTaskSettings.jobClusterKey) &&
                Objects.equals(this.notebookTask, jobTaskSettings.notebookTask) &&
                Objects.equals(this.sparkJarTask, jobTaskSettings.sparkJarTask) &&
                Objects.equals(this.sparkPythonTask, jobTaskSettings.sparkPythonTask) &&
                Objects.equals(this.sparkSubmitTask, jobTaskSettings.sparkSubmitTask) &&
                Objects.equals(this.pipelineTask, jobTaskSettings.pipelineTask) &&
                Objects.equals(this.pythonWheelTask, jobTaskSettings.pythonWheelTask) &&
                Objects.equals(this.libraries, jobTaskSettings.libraries) &&
                Objects.equals(this.emailNotifications, jobTaskSettings.emailNotifications) &&
                Objects.equals(this.timeoutSeconds, jobTaskSettings.timeoutSeconds) &&
                Objects.equals(this.maxRetries, jobTaskSettings.maxRetries) &&
                Objects.equals(this.minRetryIntervalMillis, jobTaskSettings.minRetryIntervalMillis) &&
                Objects.equals(this.retryOnTimeout, jobTaskSettings.retryOnTimeout);
    }

    @Override
    public int hashCode() {
        return Objects.hash(taskKey, description, dependsOn, existingClusterId, newCluster, jobClusterKey, notebookTask, sparkJarTask, sparkPythonTask, sparkSubmitTask, pipelineTask, pythonWheelTask, libraries, emailNotifications, timeoutSeconds, maxRetries, minRetryIntervalMillis, retryOnTimeout);
    }


    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class JobTaskSettings {\n");

        sb.append("    taskKey: ").append(toIndentedString(taskKey)).append("\n");
        sb.append("    description: ").append(toIndentedString(description)).append("\n");
        sb.append("    dependsOn: ").append(toIndentedString(dependsOn)).append("\n");
        sb.append("    existingClusterId: ").append(toIndentedString(existingClusterId)).append("\n");
        sb.append("    newCluster: ").append(toIndentedString(newCluster)).append("\n");
        sb.append("    runJobTask: ").append(toIndentedString(runJobTask)).append("\n");
        sb.append("    jobClusterKey: ").append(toIndentedString(jobClusterKey)).append("\n");
        sb.append("    notebookTask: ").append(toIndentedString(notebookTask)).append("\n");
        sb.append("    sparkJarTask: ").append(toIndentedString(sparkJarTask)).append("\n");
        sb.append("    sparkPythonTask: ").append(toIndentedString(sparkPythonTask)).append("\n");
        sb.append("    sparkSubmitTask: ").append(toIndentedString(sparkSubmitTask)).append("\n");
        sb.append("    pipelineTask: ").append(toIndentedString(pipelineTask)).append("\n");
        sb.append("    pythonWheelTask: ").append(toIndentedString(pythonWheelTask)).append("\n");
        sb.append("    libraries: ").append(toIndentedString(libraries)).append("\n");
        sb.append("    emailNotifications: ").append(toIndentedString(emailNotifications)).append("\n");
        sb.append("    timeoutSeconds: ").append(toIndentedString(timeoutSeconds)).append("\n");
        sb.append("    maxRetries: ").append(toIndentedString(maxRetries)).append("\n");
        sb.append("    minRetryIntervalMillis: ").append(toIndentedString(minRetryIntervalMillis)).append("\n");
        sb.append("    retryOnTimeout: ").append(toIndentedString(retryOnTimeout)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }
}

